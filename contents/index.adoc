= Building Java Libraries

This guide walks you through the process of using Gradle's Build Init plugin to produce a JVM library which is suitable for consumption by other JVM libraries and applications.

== What you’ll build

You'll generate a Java library that uses the standard project layout.

== What you’ll need

 - About +++<span class="time-to-complete-text"></span>+++
 - A text editor or IDE
 - A http://www.oracle.com/technetwork/java/javase/downloads/index.html[Java Development Kit] (JDK)
 ** version 7 or higher if using the Gradle Groovy DSL
 ** version 8 or higher if using the Gradle Kotlin DSL
 - A https://gradle.org/install[Gradle distribution], version {gradle-version} or better

== Create a library project

Gradle comes with the built-in {user-manual}build_init_plugin.html[Build Init Plugin]. Unlike other plugins, this one doesn't require a Gradle project since it's used to create such projects. The plugin provides one task — `init` — that generates projects of various types and you'll use it now to create a new Java library project.

The first step is to create a folder for the new project and `cd` into it:

[listing]
----
$ mkdir building-java-libraries
$ cd building-java-libraries
----

== Run the init task

From inside your newly-created directory, run the `init` task with the following argument(s):

.If you prefer the Groovy DSL
[source.multi-language-sample,groovy]
----
$ gradle init --type java-library
include::{gradle-outdir}/groovy-dsl-initOutput/out.txt[]
----

.If you prefer the Kotlin DSL
[source.multi-language-sample,kotlin]
----
$ gradle init --type java-library --dsl kotlin
include::{gradle-outdir}/kotlin-dsl-initOutput/out.txt[]
----

This will create several files and directories, including a {user-manual}gradle_wrapper.html[Gradle Wrapper] that matches the version of Gradle that you used to run `init`. The complete directory structure looks like this:

.Groovy DSL
[source.multi-language-sample,groovy]
----
include::groovy-dsl/project-structure.txt[]
----

.Kotlin DSL
[source.multi-language-sample,kotlin]
----
include::kotlin-dsl/project-structure.txt[]
----

<1> Generated folder for wrapper files
<2> Default Java source folder
<3> Default Java test folder

You now have the necessary components for a simple Java library project.

== Review the generated project files

The settings file — either `settings.gradle` or `settings.gradle.kts` — is used to configure structural aspects of the build. In this case, it only configures the name of the project:

.Generated settings.gradle
[source.multi-language-sample,groovy]
----
include::{gradle-outdir}/groovy-dsl-files/settings.gradle[]
----

.Generated settings.gradle.kts
[source.multi-language-sample,kotlin]
----
include::{gradle-outdir}/kotlin-dsl-files/settings.gradle.kts[]
----
<1>  This assigns the name of the root project.

The generated build script — either `build.gradle` or `build.gradle.kts` — defines what needs to be done by the build. The non-comment portion is reproduced here, although be aware that you may see different dependency versions if you're using another version of Gradle:

.Generated build.gradle
[source.multi-language-sample,groovy]
----
include::{gradle-outdir}/groovy-dsl-files/build.gradle[tags=init]
----

.Generated build.gradle.kts
[source.multi-language-sample,kotlin]
----
include::{gradle-outdir}/kotlin-dsl-files/build.gradle.kts[tags=init]
----

<1> Public Bintray Artifactory repository
<2> This is an example of a dependency which is exported to consumers, that is to say found on their compile classpath.
<3> This is an example of a dependency which is used internally, and not exposed to consumers on their own compile classpath.
<4> JUnit testing library

This is a very short build script, but it provides everything you need to build the project. That's because the detail of how to build Java library projects is packaged in the {user-manual}java_library_plugin.html[Java Library Plugin], which is applied to the build right at the start.

TIP: You can learn more about the differences between the `api` and `implementation` configurations in the {user-manual}building_java_projects.html#sec:building_java_libraries[user manual].

The file `src/main/java/Library.java` is shown here:

.Generated src/main/java/Library.java
[source,java]
----
include::{gradle-outdir}/groovy-dsl-files/src/main/java/Library.java[tags=source-code]
----

The generated JUnit specification, `src/test/java/LibraryTest.java` is shown next:

.Generated  src/test/java/LibraryTest.java
[source,java]
----
include::{gradle-outdir}/groovy-dsl-files/src/test/java/LibraryTest.java[]
----

The generated test class has a single http://junit.org/junit4/[JUnit 4] test. The test instantiates the `Library` class, invokes the `someLibraryMethod()` method, and checks that the returned value is `true`.

== Assemble the library JAR

Now that the project has been created, you will {guides}/creating-new-gradle-builds/#switch_to_wrapper[switch to using the Gradle Wrapper]. Run the `build` task to perform a complete build:

[listing]
----
$ ./gradlew build
include::{gradle-outdir}/groovy-dsl-buildOutput/out.txt[]
----

The `build` task compiles the classes, runs the tests, generates a test report, and packages the library as a JAR. You can view the test report by opening the HTML output file, located at `build/reports/tests/test/index.html`.

NOTE: The first time you run the build, Gradle will check whether or not you already have the JUnit libraries and other listed dependencies in your dependency cache. If not, the libraries will be downloaded and stored there. The next time you run the build, the cached versions will be used.

A sample test report is shown here:

image::Test-Summary.png[]

You will find your newly packaged JAR file in the `build/libs` directory with the name `building-java-libraries.jar`. Verify that the archive is valid by running the following command:

----
$ jar tf build/libs/building-java-libraries.jar
META-INF/
META-INF/MANIFEST.MF
Library.class
----

You should see the required manifest file — `MANIFEST.MF` — and the compiled `Library` class.

[NOTE]
====
All of this happens without any additional configuration in the build script because the Java Library Plugin assumes your project sources are arranged in a {user-manual}java_plugin.html#sec:java_project_layout[conventional project layout]. You can customize the project layout using the approach {user-manual}java_plugin.html#sec:changing_java_project_layout[described in the user manual].
====

Congratulations, you have just completed the first step of creating a Java library! You can can now customize this to your own project needs.

== Customize the library JAR

We recommend that all projects should be versioned, but it's particularly important for libraries because they have consumers. Providing a version is easily done by setting a top-level `version` property in the build script, like so:

.build.gradle
[source.multi-language-sample,groovy]
----
include::{gradle-outdir}/groovy-dsl-files/build.gradle[tags=version]
----

.build.gradle.kts
[source.multi-language-sample,kotlin]
----
include::{gradle-outdir}/kotlin-dsl-files/build.gradle.kts[tags=version]
----

You can run `build` again, but you can also run `jar`, which only executes the tasks required to create the JAR file:

----
$ ./gradlew jar
----

You should see that the resulting JAR file at `build/libs/building-java-libraries-0.1.0.jar` contains the version. You should also see that the tests weren't run this time since they aren't required for building the JAR.

Another common requirement for Java library projects is to customize the JAR's manifest file, typically by adding one or more attributes. As an example, you'll include the library name and version in the manifest file by {user-manual}more_about_tasks.html#sec:configuring_tasks[configuring the `jar` task].

Add the following to the end of your build script:

.build.gradle
[source.multi-language-sample,groovy]
----
include::{gradle-outdir}/groovy-dsl-files/build.gradle[tags=jar-manifest]
----

.build.gradle.kts
[source.multi-language-sample,kotlin]
----
include::{gradle-outdir}/kotlin-dsl-files/build.gradle.kts[tags=jar-manifest]
----

To confirm that these changes work as expected, run the `jar` task again. This time, also unpack the manifest file from the JAR:

----
$ ./gradlew jar
$ jar xf build/libs/building-java-libraries-0.1.0.jar META-INF/MANIFEST.MF
----

Now view the contents of the `META-INF/MANIFEST.MF` file and you should see the following:

[source,mf]
.META-INF/MANIFEST.MF
----
include::{gradle-outdir}/groovy-dsl-unpackJar/META-INF/MANIFEST.MF[]
----

[NOTE]
.Learn more about configuring JARs
====
The `manifest` is just one of many properties that can be configured on the `jar` task. For a complete list, see the {language-reference}org.gradle.api.tasks.bundling.Jar.html[Jar section] of the {language-reference}[Gradle Language Reference] as well as the {user-manual}java_plugin.html#sec:jar[Jar] and {user-manual}working_with_files.html#sec:archives[Creating Archives] sections of the Gradle {user-manual}userguide.html[User Manual].
====

== Add API documentation

The Java Library Plugin has built-in support for Java's API documentation tool via the `javadoc` task, which is of type {language-reference}org.gradle.api.tasks.javadoc.Javadoc.html[`Javadoc`].

The code generated by the Build Init plugin already has a standard Java comment in the `Library.java` file. To make this appear in the Javadoc report, you just need to add an extra `++*++` so you end up with `/++**++`:

.src/main/java/Library.java
[source,java]
----
include::{gradle-outdir}/groovy-dsl-files/src/main/java/Library.java[tags=java-doc]
----

Now run the `javadoc` task:

[listing]
----
$ ./gradlew javadoc

include::{gradle-outdir}/groovy-dsl-docOutput/out.txt[]
----

You can view the generated API documentation by opening the HTML file located at `build/docs/javadoc/index.html`.

== Summary

That's it! You've now successfully built a Java library project that can be used by other projects. Along the way, you've learned how to:

* Generate a Java library project
* Run the build and view the test report
* Customize the name of the library's JAR file and the contents of its manifest
* Generate the project's API documentation.

== Next steps

Building a library is just one aspect of reusing code across project boundaries. From here, you may be interested in:

 - {user-manual}artifact_dependencies_tutorial.html[Consuming JVM libraries]
 - {user-manual}artifact_management.html[Publishing JVM libraries]
 - {user-manual}intro_multi_project_builds.html[Working with multi-project builds]


include::contribute[repo-path="gradle-guides/building-java-libraries"]
